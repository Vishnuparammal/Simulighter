<html>
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="initial-scale=1.0" />
	<title>Light Simulator</title>

	<script src="p5.js"></script>

	<style type="text/css">
		html, body {
			padding: 0px;
			margin: 0px;
		}
		ul.toolbar li{
			float: left;
			padding-left: 1em;
			padding-bottom: 5px;
		}

		div.edit-toolbar {
			float: right;
			margin: 0.5em;
		}

		ul.toolbar li button {
			background-color: #262626;
			border-width: 0px;
			color: white;
			padding: 0.8em 1.2em 0.8em 1.2em;
		}
		ul.toolbar li button:hover {
			background-color: #000000;
		}
	</style>
</head>
<body>

	<div style="padding: 0;">
		<ul style="list-style-type: none;" class="toolbar">
			<li><button id="ray-btn">Ray</button></li>
			<li><button id="lens-btn">Lens</button></li>
			<li><button id="mirror-btn">Mirror</button></li>
		</ul>
	</div>
	<div class="edit-toolbar">
		<button id="undo">Undo</button>
		<button id="redo">Redo</button>
	</div>
	<div id="sketch-holder">
		<!-- Our sketch will go here! -->
	</div>
	<script type="text/javascript">

		let Point = function(x,y){
			this.x = x;
			this.y = y;

			if(typeof this.draw !== 'function'){
				Point.prototype.draw = function(){
					push();
					fill(255,0,0);
					stroke(255,0,0);
					strokeWeight(4);
					point(this.x, this.y);
					pop();
				};
			}

		}

		let Line  = function(p1, p2){
			if(typeof Line.prototype.type === "undefined")
				Line.prototype.type = "Line";

			this.start = p1;
			this.next  = p2;
			this.id = Math.random();

			if(typeof this.getSlope !== 'function'){
				Line.prototype.getSlope = function(){
					return (this.start.y - this.next.y)/(this.start.x - this.next.x);
				}
			}

			if(typeof this.extend !== 'function'){
				Line.prototype.extend = function(x,y,check,body=undefined){
					if (check==1)
					{
						//console.log('should return line');
						console.log(this.id);
						this.next = new Point(x,y);
						
						var lineSlope = this.getSlope();
						var lineInclination = atan2((this.next.y-this.start.y),(this.next.x-this.start.x));
						if (lineInclination<0){
							lineInclination+=2*PI;
						}
						var ly = this.next.y;
						var lx = this.next.x;
						var normalSlope;
						
						switch(body.type){
						case 'Mirror':
							normalSlope = (ly-body.center.y)/(lx-body.center.x);
							break;
						//default: return undefined;
						}
						
						if (normalSlope == -1/lineSlope)
							lineAngle = PI/2;
						else
							lineAngle = abs((lineSlope - normalSlope)/(1+lineSlope*normalSlope));
						//console.log(lineAngle*180/PI);
						if (lineSlope>normalSlope){
							var nx = cos(lineInclination - 2*lineAngle) + lx;
							var ny = sin(lineInclination - 2*lineAngle) + ly;
						}
						else{
							var nx = cos(lineInclination + 2*lineAngle) + lx;
							var ny = sin(lineInclination + 2*lineAngle) + ly;
						}
						//console.log(nx);
						
						let new1Line1 = new Line(this.next, new Point(nx, ny));
							return new1Line1;
							
							
						
					}
					else
						{
						//console.log('should return undefined');
						this.next= new Point(x,y);
						if(this.next.y==this.start.y)
							extend=1;
						else
							extend=2;
					
						switch(extend){
							case 1:
								if(this.next.x>this.start.x)
									extend=windowWidth;
								else if(this.next.x<this.start.x)
									extend=0;
								this.next.x=extend;
								break;
							case 2:
								if(this.next.y>this.start.y)
									extend=windowHeight;
								else if (this.next.y<this.start.y)
									extend=0;
								this.next.x=(extend-this.start.y)/(this.next.y-this.start.y)*(this.next.x-this.start.x)+this.start.x;
								this.next.y=extend;
								break;
						}
				//return undefined;
				}
				}
			}
			
			if(typeof this.draw !== 'function'){
				Line.prototype.draw = function(){
					line(this.start.x, this.start.y, this.next.x, this.next.y);
				};
			}

			if(typeof this.checkIntersect !== 'function'){
				Line.prototype.checkIntersect = function(body){
					switch(body.type){
						case "Mirror":
							let lineSlope = this.getSlope();
							let distance = abs((lineSlope*body.center.x-body.center.y-lineSlope*this.start.x+this.start.y)/(sqrt(1 + lineSlope ** 2)));
							if (distance>=body.roc)
								break;
							
							let eqConst = (this.start.y - body.center.y + lineSlope*(body.center.x - this.start.x))/body.roc;
							let alpha   = acos(-lineSlope/(sqrt(1 + lineSlope ** 2)));
							let beta = acos(eqConst/(sqrt(1 + lineSlope ** 2)));
							let theta1 = alpha - beta;
							let theta2 = alpha + beta;
							let mini = body.angle+body.tempangle;
							let maxi = -body.angle+body.tempangle;

							if (theta1<0)
								theta1+=2*PI;
							
							//console.log('theta1 '+ theta1*180/PI);
							//console.log('theta2 '+ theta2*180/PI);
						
							while (mini<0){
								mini+=2*PI;
							}
							while (mini>=2*PI){
								mini-=2*PI;
							}
							while (maxi<0){
								maxi+=2*PI;
							}
							while (maxi>=2*PI){
								maxi-=2*PI;
							}
							
							let p1,p2;

							if (mini>maxi)
							{
								if((theta1>mini&&theta1<2*PI)||(theta1>0&&theta1<maxi))
									{
										p1 = new Point(
									 	(body.roc * cos(theta1) + body.center.x),
									 	(body.roc * sin(theta1) + body.center.y)
									 	);
									 	//console.log('p1');
									 	p1.draw();
									 	if (p1.x == this.start.x && p1.y == this.start.y)
											return this.extend(p1.x,p1.y,0);
										else
											return this.extend(p1.x,p1.y,1,body);
									 	
									 	
									}
							
								if((theta2>mini&&theta2<2*PI)||(theta2>0&&theta2<maxi))
									{
										p2 = new Point(
									 	(body.roc * cos(theta2) + body.center.x),
									 	(body.roc * sin(theta2) + body.center.y)
									 	);
									 	//console.log('p2');
									 	p2.draw();
									 	if (p2.x == this.start.x && p2.y == this.start.y)
											return this.extend(p2.x,p2.y,0);
									 	else
									 		return this.extend(p2.x,p2.y,1,body);
									 	
									}
							}

							//console.log('mini '+ mini*180/PI + ' maxi '+ maxi*180/PI);
						
							else
							{
								if(theta1<maxi&&theta1>mini)
								{
									p1 = new Point(
								 	(body.roc * cos(theta1) + body.center.x),
								 	(body.roc * sin(theta1) + body.center.y)
								 	);
								 	//console.log('p1');
								 	p1.draw();
								 	if (p1.x == this.start.x && p1.y == this.start.y)
										return this.extend(p1.x,p1.y,0);
								 	else
								 		return this.extend(p1.x,p1.y,1,body);
								 	
								 	
								}
								
								if(theta2<maxi&&theta2>mini)
								{
									p2 = new Point(
								 	(body.roc * cos(theta2) + body.center.x),
								 	(body.roc * sin(theta2) + body.center.y)
								 	);
								 	//console.log('p2');
								 	p2.draw();
								 	if (p2.x == this.start.x && p2.y == this.start.y)
										return this.extend(p2.x,p2.y,0);
								 	else
								 		return this.extend(p2.x,p2.y,1,body);
								 	
								}
							}

							// var firstIntersection = sqrt((p1.x - this.start.x)**2 + (p1.y - this.start.y)**2); 
							// var secondIntersection = sqrt((p2.x - this.start.x)**2 + (p2.y - this.start.y)**2);
							// if (firstIntersection<=secondIntersection)
							// 	return this.extend(p1.x,p1.y,1,body);
							// else
							// 	return this.extend(p2.x,p2.y,1,body); 
							//return undefined;
							break;
						
						case "Lens":

							break;
					}
				}
			}
			
		};
		
		let Ray = function(p1, p2){
			if(typeof Ray.prototype.type === "undefined")
				Ray.prototype.type = "Ray";

			this.start = p1; 	//START POINT OF RAY
			this.next  = p2;	//NEXT POINT OF RAY, NOT NECESSARILY ON ANY LINE
			this.lineList   = [new Line(this.start,this.next)];//todo EMPTY THIS AND FILL IN lines IN IT EVERY TIME

			if(typeof this.draw !== 'function')
				Ray.prototype.draw = function(){
					this.lineList.forEach(function(Line){
						Line.draw();
					});
					this.lineList = []; //todo EMPTIES THE LIST OF LINES IN THE RAY, SO NEXT ROUND PF CALCULATIONS CAN TAKE PLACE
				}

			if(typeof this.emptyList !== 'function'){
				Ray.prototype.emptyList = function(){
					this.lineList = [];
				}
			}
			
			//todo RAY INTERSECTION CHECKING, ideally should work but please go through the logic as this 
			//is the most crucial part
			if(typeof this.checkIntersect !== 'function'){
				Ray.prototype.checkIntersect = function(bodiesList){
					//todo ASSUMPTION: this.lineList is empty at this point, and we are calculating possible lines of the RAY
					//Added first line into this.lineList
					
					this.lineList   = [new Line(this.start,this.next)];

					for(i=0; i<this.lineList.length; i++){
						//Gets the latest line
						let currLine = this.lineList[i];
						
						let reflectedLine = undefined;
						let body;
						for(j=0; j<bodiesList.length; j++){
							reflectedLine = currLine.checkIntersect(bodiesList[j]);
							if(reflectedLine !== undefined){
								body = bodiesList[j];
								break;}//Found our intersection
						}
						//console.log(reflectedLine);
						if(reflectedLine === undefined){
							//console.log(currLine.next);
							//console.log('in curr extend');
							currLine.extend(currLine.next.x,currLine.next.y,0);
							//continue;
						}
						else{
							//console.log('in line push');
							//WE found an intersection point, so we must add a new line to the list
							//and shorten the current line till the intersection point
							//this.lineList[i].extend(reflectedLine.start.x, reflectedLine.start.y, 1, body);
							this.lineList.push(reflectedLine);
						}
					}
					
					this.lineList.forEach(function(line){
						line.draw();
					});
				}
			}
		};

		let Mirror = function(p1,p2,p3,roc){
			if(typeof Mirror.prototype.type === "undefined")
				Mirror.prototype.type = "Mirror";
			this.roc = roc;
			this.pole=p1;
			this.start=p2;
			this.end = p3;
			this.tempangle=0;
			
			this.center=new Point(this.pole.x-roc,this.pole.y);
			this.angle=atan2((this.start.y-this.center.y),(this.start.x-this.center.x));
      
			if(typeof this.setStart !=='function'){
		      		Mirror.prototype.setStart = function(x, y){
					this.start = new Point(x,y);
					this.angle=atan2((this.start.y-this.center.y),(this.start.x-this.center.x));
					//console.log('angle '+this.angle*180/PI);
					
        			}
      			}
      
			if(typeof this.setEnd !=='function'){
		      		Mirror.prototype.setEnd = function(x, y){
					this.end = new Point(x,y);
					this.tempangle = atan2((this.end.y-this.pole.y),(this.end.x-this.pole.x));
					//console.log('tempangle for center '+this.tempangle*180/PI);
					this.center.x=this.roc*cos(this.tempangle) +this.pole.x;			
					this.center.y=(this.roc*sin(this.tempangle) + this.pole.y);
					this.tempangle +=PI;
					
        			}
     			}
			
			if(typeof this.draw !=='function'){
				Mirror.prototype.draw = function(){
					push();
		  			noFill();
		  			arc(this.center.x,this.center.y,this.roc*2,this.roc*2,this.angle+this.tempangle,-this.angle+this.tempangle);
		  			pop();
		  			this.pole.draw();
		  			this.center.draw();
				};
			}
			
		};

		let Lens = function(p1,p2,p3,roc){
			if(typeof Lens.prototype.type === "undefined")
				Lens.prototype.type = "Lens";

			this.roc = roc;
			this.pole=p1;
			this.start=p2;
			this.end = p3;
			this.angle=PI/2;
			this.tempangle=0;
			this.center1=new Point(this.pole.x-roc*cos(this.angle),this.pole.y);
			this.center2=new Point(this.pole.x+roc*cos(this.angle),this.pole.y);
			      
			if(typeof this.setStart !=='function'){
		      		Lens.prototype.setStart = function(x, y){
				this.start = new Point(x,y);
					if (abs(this.pole.y-this.start.y)<=this.roc && abs(this.pole.y-this.start.y)>0)
						this.angle=asin(abs(this.pole.y-this.start.y)/this.roc);
					else	
						this.angle=PI/2;
					this.center1=new Point(this.pole.x-this.roc*cos(this.angle),this.pole.y);
					this.center2=new Point(this.pole.x+this.roc*cos(this.angle),this.pole.y);
        			}
      			}

			if(typeof this.setEnd !=='function'){
			      	Lens.prototype.setEnd = function(x, y){
					this.end = new Point(x,y);
					this.tempangle = atan2((this.end.y-this.pole.y),(this.end.x-this.pole.x));
					this.center1.x=this.roc*cos(this.angle)*cos(this.tempangle) + this.pole.x;			
					this.center1.y=this.roc*cos(this.angle)*sin(this.tempangle) + this.pole.y;
					this.center2.x=this.roc*cos(this.angle)*cos(this.tempangle+PI) + this.pole.x;			
					this.center2.y=this.roc*cos(this.angle)*sin(this.tempangle+PI) + this.pole.y;
					
					this.tempangle += PI;
        			}
			}
			
			if(typeof this.draw !=='function'){
				Lens.prototype.draw = function(){
					push();
		  			arc(this.center1.x,this.center1.y,this.roc*2,this.roc*2,-this.angle+this.tempangle,this.angle+this.tempangle,OPEN);
					arc(this.center2.x,this.center2.y,this.roc*2,this.roc*2,-this.angle+this.tempangle + PI,this.angle+this.tempangle + PI,OPEN);
		  			pop();
		  			this.pole.draw();
		  			this.center1.draw();
					this.center2.draw();

				};
			}
			
		};

		let bodyList     = [];
		let state        = {};
		let tempRedoList = [];
		let rayList     = [];


		document.querySelectorAll("ul.toolbar li button").forEach(function(button){
			button.onclick = function(){
				if(state.newBody !== undefined)
					bodyList.pop();
				state = {newBody:button.id, step:0};
			}
		});

		document.getElementById("undo").onclick = function(){
			if(state.newBody !== undefined){
				//to-dos UNDO FOR PENDING BODIES
			}
			else{
				if(bodyList.length > 0)
					tempRedoList.push(bodyList.pop());
			}
		}

		document.getElementById("redo").onclick = function(){
			if(state.newBody !== undefined){
				//to-dos UNDO FOR PENDING BODIES
			}
			else{
				if(tempRedoList.length > 0)
					bodyList.push(tempRedoList.pop());
			}
		}

		function setup(){
			let canvas = createCanvas(windowWidth, windowHeight);
			canvas.parent('sketch-holder');
		}

		function mousePressed(){
			if(state.newBody === undefined)
				return

			switch(state.newBody){
				case 'ray-btn':
					switch(state.step){
						case 0:
							let newRay1 = new Ray(new Point(mouseX, mouseY), new Point(mouseX, mouseY));
							bodyList.push(newRay1);
							rayList.push(newRay1);
							state.step = 1;
							break;
						case 1:
							let newRay  = rayList.pop();
							bodyList.pop();
							bodyList.push(newRay);
							rayList.push(newRay);
							state = {};
							break;
					}
				break;
				case 'mirror-btn':
					switch(state.step){
						case 0:
							roc = 2*prompt('enter focal length');
							bodyList.push(new Mirror(new Point(mouseX,mouseY),new Point(mouseX,mouseY),new Point(mouseX,mouseY),roc));
							state.step = 1;
							break;
						case 1:
							let newMirror = bodyList.pop();
							newMirror.start = new Point(mouseX,mouseY);
							bodyList.push(newMirror);
							state.step = 2;
							break;
		   				case 2:
						   	let new2Mirror = bodyList.pop();
							new2Mirror.end = new Point(mouseX,mouseY);
							bodyList.push(new2Mirror);
							state = {};
							break;
					}
				break;
				case 'lens-btn':
					switch(state.step){
						case 0:
							roc = 2*prompt('enter focal length');
							bodyList.push(new Lens(new Point(mouseX,mouseY),new Point(mouseX,mouseY),new Point(mouseX,mouseY),roc));
							state.step = 1;
							break;
						case 1:
							let newLens = bodyList.pop();
							newLens.start = new Point(mouseX,mouseY);
							bodyList.push(newLens);
							state.step = 2;
							break;
						case 2:
					   		let new2Lens = bodyList.pop();
							new2Lens.end = new Point(mouseX,mouseY);
							bodyList.push(new2Lens);
							state = {};
							break;
					}
      				break;
			}
		}

		function mouseMoved(){
			if(state.newBody === undefined)
				return;

			switch(state.newBody){
				case 'ray-btn':
					switch(state.step){
						case 1:
							let newRay  = rayList.pop();
							bodyList.pop();
							newRay = new Ray(newRay.start, new Point(mouseX,mouseY));
							bodyList.push(newRay);
							rayList.push(newRay);
							break;
					}
				break;
				case 'mirror-btn':
					switch(state.step){
						case 1:
							let newMirror = bodyList.pop();
							newMirror.setStart(mouseX,mouseY);
							bodyList.push(newMirror);
							break;
						case 2:
					    		let new2Mirror = bodyList.pop();
							new2Mirror.setEnd(mouseX,mouseY);
							bodyList.push(new2Mirror);
							break;
					}
				break;
				case 'lens-btn':
					switch(state.step){
						case 1:
							let newLens = bodyList.pop();
							newLens.setStart(mouseX,mouseY);
							bodyList.push(newLens);
							break;
						case 2:
					    		let new2Lens = bodyList.pop();
							new2Lens.setEnd(mouseX,mouseY);
							bodyList.push(new2Lens);
							break;
					}
				break;
			}
		}
		function drawGrid(){      
			push();
			stroke(0);
			strokeWeight(1);			
			for(i=0;i<=windowWidth;i+=10)
			    line(i,0,i,windowHeight);
			for(i=0;i<=windowHeight;i+=10)
				line(0,i,windowWidth,i);
			pop();
		}

		function draw(){
			background(38);
			stroke(255);
			strokeWeight(4);
			fill(100);
			new Point(0,0).draw();
			drawGrid();

			

			rayList.forEach(function(ray){
				ray.checkIntersect(bodyList);
				//console.log(ray.lineList);
			});
			
			bodyList.forEach(function(body){
				body.draw();
			});
		}
		
	</script>
</body>
</html>
